#### 让服务程序运行在后台

两种方法：

- ./可执行程序名  &
- 在程序中fork( )一个子进程来执行服务程序，父进程退出（子进程将被托管于init）。

中止后台程序：

```shell
1）killall 可执行程序名
2）ps -ef grep book	//找到进程号
   kill 进程号
```



#### 信号的使用

在程序中设置捕获信号，绑定该信号的信号处理函数。

```c
#include <signal.h>

void func(int sig){
    printf("收到了信号%d\n", sig);
    /*------------其他中止操作------------*/
}
signal(SIGINT, func);	//SIGINT是键盘Ctrl+C产生的信号
signal(SIGTERM, func);	//SIGINT是“kill+进程编号”或“kill+程序名”产生的信号
```

程序在运行的过程中，用Ctrl+C、kill、killall 中止 的本质是向程序发送信号，程序对这两个信号的缺省行为是中止运行程序。

在程序中，通过捕获信号，编写信号处理函数，可以执行其他操作。

在实际开发中，信号用于服务程序的退出。

​		**signal信号是进程之间相互传递消息的一种方法，信号全称为软中断信号，也有人称作软中断，从它的命名可以看出，它的实质和使用很像中断。**

##### 信号的基本概念

​		软中断信号（signal，又简称为信号）用来通知进程发生了事件。进程之间可以通过调用kill库函数发送软中断信号。Linux内核也可能给进程发送信号，通知进程发生了某个事件（例如内存越界）。

注意，信号只是用来通知某进程发生了什么事件，无法给进程传递任何数据，进程对信号的处理方法有三种：

1）第一种方法是，忽略某个信号，对该信号不做任何处理，就象未发生过一样。

2）第二种是设置中断的处理函数，收到信号后，由该函数来处理。

3）第三种方法是，对该信号的处理采用系统的默认操作，大部分的信号的默认操作是终止进程。



##### 信号的类型

发出信号的原因很多，这里按发出信号的原因简单分类，以了解各种信号：

| 信号名      | 信号值       | 默认处理动作 | 发出信号的原因                                       |
| ----------- | ------------ | ------------ | ---------------------------------------------------- |
| SIGHUP      | 1            | A            | 终端挂起或者控制进程终止                             |
| **SIGINT**  | **2**        | **A**        | **键盘中断Ctrl+c**                                   |
| SIGQUIT     | 3            | C            | 键盘的退出键被按下                                   |
| SIGILL      | 4            | C            | 非法指令                                             |
| SIGABRT     | 6            | C            | 由abort(3)发出的退出指令                             |
| SIGFPE      | 8            | C            | 浮点异常                                             |
| **SIGKILL** | **9**        | **AEF**      | **采用kill  -9 进程编号 强制杀死程序。**             |
| **SIGSEGV** | **11**       | **C**        | **无效的内存引用**                                   |
| SIGPIPE     | 13           | A            | 管道破裂:写一个没有读端口的管道                      |
| SIGALRM     | 14           | A            | 由alarm(2)发出的信号                                 |
| **SIGTERM** | **15**       | **A**        | **采用“kill  进程编号”或“killall 程序名”通知程序。** |
| SIGUSR1     | 30,10,16     | A            | 用户自定义信号1                                      |
| SIGUSR2     | 31,12,17     | A            | 用户自定义信号2                                      |
| **SIGCHLD** | **20,17,18** | **B**        | **子进程结束信号**                                   |
| SIGCONT     | 19,18,25     |              | 进程继续（曾被停止的进程）                           |
| SIGSTOP     | 17,19,23     | DEF          | 终止进程                                             |
| SIGTSTP     | 18,20,24     | D            | 控制终端（tty）上按下停止键                          |
| SIGTTIN     | 21,21,26     | D            | 后台进程企图从控制终端读                             |
| SIGTTOU     | 22,22,27     | D            | 后台进程企图从控制终端写                             |

处理动作一项中的字母含义如下

A 缺省的动作是终止进程。

B 缺省的动作是忽略此信号，将该信号丢弃，不做处理。

C 缺省的动作是终止进程并进行内核映像转储（core dump），内核映像转储是指将进程数据在内存的映像和进程在内核结构中的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是为程序员 提供了方便，使得他们可以得到进程当时执行时的数据值，允许他们确定转储的原因，并且可以调试他们的程序。

D 缺省的动作是停止进程，进入停止状况以后还能重新进行下去。

E 信号不能被捕获。

F 信号不能被忽略。



##### signal库函数

signal库函数可以设置程序对信号的处理方式。

函数声明：

```c
sighandler_t signal(int signum, sighandler_t handler);
```

参数signum表示信号的编号。

参数handler表示信号的处理方式，有三种情况：

1）SIG_IGN：忽略参数signum所指的信号。

2）一个自定义的处理信号的函数，**信号的编号为这个自定义函数的参数**。

3）SIG_DFL：恢复参数signum所指信号的处理方法为默认值。 

程序员不关心signal的返回值。



##### 信号的作用

​		服务程序运行在后台，如果想让中止它，强行杀掉不是个好办法，因为程序被杀的时候，程序突然死亡，没有释放资源，会影响系统的稳定，用Ctrl+c中止与杀程序是相同的效果。

​		如果能向后台程序发送一个信号，后台程序收到这个信号后，调用一个函数，在函数中编写释放资源的代码，程序就可以有计划的退出，安全而体面。

​		信号还可以用于网络服务程序抓包等，这是较复杂的应用场景。



##### 信号应用示例

在实际开发中，在main函数开始的位置，程序员会先屏蔽掉全部的信号。

```c
for (int i = 0; i <= 64; i++) signal(i, SIG_IGN);
```

这么做的目的是不希望程序被干扰。然后，再设置程序员关心的信号的处理函数。

程序员关心的信号有三个：SIGINT、SIGTERM和SIGKILL。

程序在运行的进程中，如果按Ctrl+c，将向程序发出SIGINT信号，信号编号是2。

采用“kill 进程编号”或“killall 程序名”向程序发出的是SIGTERM信号，编号是15。

采用“kill -9 进程编号”向程序发出的是SIGKILL信号，编号是9，此信号不能被忽略，也无法捕获，程序将突然死亡。

所以，程序员只要设置SIGINT和SIGTERM两个信号的处理函数就可以了，这两个信号可以使用同一个处理函数，函数的代码是释放资源。

此时，不管是用Ctrl+c还是kill，程序都能体面的退出。



##### 发送信号

Linux操作系统提供了kill命令向程序发送信号，C语言也提供了kill库函数，用于在程序中向其它进程或者线程发送信号。

函数声明

```c
int kill(pid_t pid, int sig);
```

kill函数将参数sig指定的信号给参数pid 指定的进程。

参数 pid 有几种情况：

1）pid > 0 将信号传给进程号为pid 的进程。

2）pid = 0 将信号传给和目前进程相同进程组的所有进程，常用于父进程给子进程发送信号，注意，发送信号者进程也会收到自己发出的信号。

3）pid=-1 将信号广播传送给系统内所有的进程，例如系统关机时，会向所有的登录窗口广播关机信息。

sig：准备发送的信号代码，假如其值为零则没有任何信号送出，但是系统会执行错误检查，通常会利用sig值为零来检验某个进程是否仍在运行。

返回值说明： 成功执行时，返回0；失败返回-1，errno被设为以下的某个值。

EINVAL：指定的信号码无效（参数 sig 不合法）。

EPERM：权限不够无法传送信号给指定进程。

ESRCH：参数 pid 所指定的进程或进程组不存在。



##### 可靠信号与不可靠信号

信号分为不可靠信号（1-32）与可靠信号（34-64）

不可靠信号主要有以下问题：

1）每次信号处理完之后，就会恢复成默认处理（早期的signal函数，linux2.6.35.6内核经验证已经不再回复默认动作）

2）存在信号丢失的问题（进程收到的信号不作排队处理，相同的信号多次到来会合并为一个）

​	  现在的Linux对信号机制进行了改进，因此不可靠信号主要是指信号丢失（eg.连续发送多次信号15，只收到2次，说明信号丢失）。



##### 信号处理函数被中断

当一个信号到达后，调用处理函数，如果这时候有其他的信号发生，会中断之前的信号处理函数，等新的信号处理函数执行完成后再继续执行之前的处理函数。

同一个信号会排队阻塞。



##### 信号的阻塞

如果不希望在接收到信号时中断当前的处理函数，也不希望忽略该信号，而是延时一段时间再处理这个信号，这种情况可以通过阻塞信号实现。

信号的阻塞和忽略信号是不同的，被阻塞的信号也不会影响进程的行为，信号只是暂时被阻止传递。

进程忽略一个信号时，信号会被传递出去，但进程会将信号丢弃。

执行信号的处理动作称为信号递达(Delivery)，信号从产生到递达之间的状态称为信号未决(Pending)。

```c
eg.信号2处理函数不希望被信号15处理函数中断
void handler2(sig){
//1）可以放在不希望被中断的处理函数头部
sigset_t set;			//信号集
sigemptyset(&set);		//清空信号集
sigaddset(&set, 15);	//把信号15加到信号集中
sigprocmask(SIG_BLOCK, &set, NULL);	//将信号集中的信号全部阻塞
/*--------信号2处理内容--------*/
/*---------------------------*/
    
//2）可以放在不希望被中断的处理函数尾部
sigprocmask(SIG_UNBLOCK, &set, NULL);	//将信号集中的信号改为非阻塞
}
void handler15(sig){
    /*-----------------------*/
}
```



**sigaction功能**

1）也可以实现信号的阻塞功能

```c
struct sigaction stact;
memeset(&stact, 0, sizeof(stact));	//初始化
stact.sa_handler = hdfunc;			//指定信号处理函数
sigaddset(&stact.sa_mask, 15);		//指定要阻塞的信号
stact.sa_flags = SA_RESTART;		//如果信号中断了进程的某个系统调用，则信号处理函数完成后
									//重新启动该系统调用
sigaction(2, &stact, NULL);			//设置信号2的处理行为
sigaction(15, &stact, NULL);		//设置信号15的处理行为
```

