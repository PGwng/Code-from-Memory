#### 内存模型

​		每一个C语言的程序被执行起来的时候系统为了更方便开发人员操作，会给每一个进程分配一个虚拟的内存空间，它实际上是从处理内存映射出来的。虚拟内存的起始地址结束地址都是固定的，因此虚拟内存的布局都是一样。比如有三个进程 P1 P2 P3 ,他们虽然得到的物理内存是完全不一样，但是从进程的角度来看他们三个得到的内存确实一模一样的。

<img src="E:\Microsoft Visual Studio\Project\Code-from-Memory\Linux\img\进程与内存.jpg" style="zoom:40%;" />

假设你正在使用的计算机实际物理内存只有 1GB 大小，而当前系统运行了三个进程，Linux 会将 PM 中的某些内存映射为三个大小均为 4GB 的虚拟内存 ，让每个进程都以为自己独自拥有了完整的内存空间，这样极大地方便了应用层程序的数据和代码的组织。

##### 虚拟内存布局：

虚拟内存布局分为内核空间、栈、堆、数据段、代码段和一个不允许访问的空间（相当于一堵墙）。

<img src="E:\Microsoft Visual Studio\Project\Code-from-Memory\Linux\img\虚拟内存布局.png" style="zoom:80%;" />

一个用户进程可以访问的内存区域介于 0x0804 8000 到0xc0000000 之间，这个“广袤”的区域又被分成了几个部分，分别用来存放进程的代码和数据。

**下面让我们更进一步地研究虚拟内存中每一个空间所存放的是什么类型的数据。**

##### 栈内存

栈内存是用于存放环境变量、命令行参数和局部变量的。栈内存空间十分有限，默认情况下栈的大小为 8M ，在嵌入式开发的时候我们应该尽可能减少使用栈空间。栈空间的增长，从上（高地址）往下（低地址）每当有一个函数被调用的时候，栈就会从上往下分配一个段，这一段空间就是一个栈帧，该内存空间用来存放该函数的局部变量。

<img src="E:\Microsoft Visual Studio\Project\Code-from-Memory\Linux\img\栈内存.png" style="zoom:80%;" />

当一个函数退出（调用结束）的时候，栈空间会从下往上释放一个栈帧，将所有的内存归还给系统。

注意：

栈空间中的内存存放的数据值是未知的， 因此每一个局部变量在使用之前最好做好初始化。

**栈内存的空间我们无法手动实现申请与释放，都是由系统自动完成，我们无法干预。**

##### 堆空间

堆空间是相对自由的空间，这是一个非常重要的区域，因为在此区域定义的内存的生命周期我们是可以控制的：从 malloc( )/calloc( )/realloc( )开始，到 free( )结束，其分配和释放完全由我们开发者自定义，这就给了我们最大的自由和灵活性，让程序在运行的过程当中，以最大的效益使用内存。

注意：

- 相对于栈空间来说，堆的内存空间相对大很多
- 堆空间的增长方式，从下（低地址）往上（高地址）
- 堆空间中的内存都属于匿名空间， 因此需要借助指针来访问
- 有开发者自行申请和释放的，如果没有释放那么这个空间将一直存在，直到程序结束。

##### 数据段

数据段中存放着全局变量、静态变量、和常量这些数据，生命周期与程序一致。程序不止，数据不断（段）。

<img src="E:\Microsoft Visual Studio\Project\Code-from-Memory\Linux\img\数据段.png" style="zoom:80%;" />

.bss中存放未初始化或者初始化为0的全局变量、静态变量。

.data存放已初始化的全局变量、静态变量。

.rodata（read only data）存放常量。

text和data段都在可执行文件中，由系统从可执行文件中加载；而bss段不在可执行文件中，由系统初始化，这个节在ELF文件中没有大小信息，并且加载到内存中后，会被分配所有字 都初始化为0的内存空间（大多数操作系统，在加载程序时，会把所有的bss全局变量全部清零，无需程序员手动去清零。但为了保证程序的可移植性，手动把这些变量初始化为0也是一个好习惯）。

.bss段只有在运行时才会有数据（也就是说，编译时没有数据），因此不是编译时分配数据，而是预留运行时的内存空间。

##### 代码段

代码段中又分成了两个空间：

.text段：存放用户的代码（main func ...）

init段：当程序运行之初的一些初始化的工作（由编译器根据系统来对应添加的）

<img src="E:\Microsoft Visual Studio\Project\Code-from-Memory\Linux\img\代码段.png" style="zoom:80%;" />

**static变量及其作用**

static 关键字不仅可以用来修饰变量，还可以用来修饰函数。在使用 static 关键字修饰变量时，我们称此变量为静态变量。

静态变量的存储方式与全局变量一样，都是静态存储方式。但这里需要特别说明的是，静态变量属于静态存储方式，属于静态存储方式的变量却不一定就是静态变量。例如，全局变量虽然属于静态存储方式，但并不是静态变量，它必须由 static 加以定义后才能成为静态全局变量。

**隐藏与隔离的作用**

上面已经阐述过，全局变量虽然属于静态存储方式，但并不是静态变量。全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，全局变量在各个源文件中都是有效的。

如果我们希望全局变量仅限于在本源文件中使用，在其他源文件中不能引用，也就是说限制其作用域只在定义该变量的源文件内有效，而在同一源程序的其他源文件中不能使用。这时，就可以通过在全局变量之前加上关键字 static 来实现，使全局变量被定义成为一个静态全局变量。这样就可以避免在其他源文件中引起的错误。也就起到了对其他源文件进行隐藏与隔离错误的作用，有利于模块化程序设计。

**保持变量内容的持久性**

有时候，我们**希望函数中局部变量的值在函数调用结束之后不会消失，而仍然保留其原值。即它所占用的存储单元不释放，在下一次调用该函数时，其局部变量的值仍然存在，也就是上一次函数调用结束时的值。这时候，我们就应该将该局部变量用关键字 static 声明为“静态局部变量”。**

当将局部变量声明为静态局部变量的时候，也就改变了局部变量的存储位置，即从原来的栈中存放改为静态存储区存放。这让它看起来很像全局变量，**其实静态局部变量与全局变量的主要区别就在于可见性，静态局部变量只在其被声明的代码块中是可见的。**

对某些必须在调用之间保持局部变量的值的子程序而言，静态局部变量是特别重要的。如果没有静态局部变量，则必须在这类函数中使用全局变量，由此也就打开了引入副作用的大门。使用静态局部变量最好的示例就是实现统计次数的功能，如下面示例所示。

```c
#include <stdio.h>
void count();
int main(void)
{
    int i=0;
    for (i = 0;i <= 5;i++)
    {
            count();
    }
    return 0;
}
void count()
{
    /*声明一个静态局部变量*/
    static num = 0;
    num++;
    printf("%d\n",num);
}
```

在该代码中，我们通过在 count() 函数里声明一个静态局部变量 num 来作为计数器。因为**静态局部变量是在编译时赋初值的，且只赋初值一次，在程序运行时它已有初值。以后在每次调用函数时就不再重新赋初值，而是保留上次函数调用结束时的值。**这样，count() 函数每次被调用的时候，静态局部变量 num 就会保持上一次调用的值，然后再执行自增运算，这样就实现了计数功能。同时，它又避免了使用全局变量。

通过上面的示例，我们可以得出静态局部变量一般的使用场景，如下所示：

- 需要保留函数上一次调用结束时的值。
- 如果初始化后，变量只会被引用而不会改变其值，则这时用静态局部变量比较方便，**以免每次调用时重新赋值**。

注意：

静态局部变量在函数内定义,**生存期为整个源程序**，但**作用域**与自动变量相同，**只能在定义该变量的函数内使用。退出该函数后， 尽管该变量还继续存在，但不能使用它**。









