#### 进程的基础知识

1）进程的基本概念

进程就是正在内存中运行中的程序，Linux下一个进程在内存里有三部分的数据，就是“代码段”、”堆栈段”和”数据段”。”代码段”，顾名思义，就是存放了程序代码。“堆栈段”存放的就是程序的返回地址、程序的参数以及程序的局部变量。而“数据段”则存放程序的全局变量，常数。

系统如果同时运行多个相同的程序，它们的“代码段”是相同的，“堆栈段”和“数据段”是不同的（相同的程序，处理的数据不同）。 

2）ps查看进程

ps 查看当前终端的进程。

ps -ef 查看系统全部的进程。

ps -ef |more 查看系统全部的进程，结果分页显示。

ps -ef |grep book查看系统全部的进程，然后从结果集中过滤出包含“book”单词的记录。程序员用得最多的指令就是这个了。

UID   ：启动进程的操作系统用户。

PID    ：进程编号。

PPID  ：进程的父进程的编号。

C        ：CPU使用的资源百分比。

STIME ：进程启动时间。

TTY   ：进程所属的终端。

TIME  ：使用掉的CPU时间。

CMD  ：执行的是什么指令。



3）getpid函数获取进程编号

getpid库函数的功能是获取本程序运行时进程的编号。

函数声明：

```c
pid_t getpid();
```

函数没有参数，返回值是进程的编号，pid_t就是typedef int pid_t。



#### 多进程的基础知识

fork在英文中是“分叉”的意思。为什么取这个名字呢？因为一个进程在运行中，如果使用了fork函数，就产生了另一个进程，于是进程就“分叉”了，所以这个名字取得很形象。下面就看看如何具体使用fork函数，这段程序演示了使用fork的基本框架。

函数声明：

```c
pid_t fork();
```

fork函数用于产生一个新的进程，函数返回值pid_t是一个整数，在父进程中，返回值是子进程编号，在子进程中，返回值是0。

那么调用这个fork函数时发生了什么呢？fork函数创建了一个新的进程，新进程（子进程）与原有的进程（父进程）一模一样。子进程和父进程使用相同的代码段；子进程拷贝了父进程的堆栈段和数据段。子进程一旦开始运行，它复制了父进程的一切数据，然后各自运行，相互之间没有影响。

fork函数对返回值做了特别的处理，调用fork函数之后，在子程序中fork的返回值是0，在父进程中fork的返回是子进程的编号，程序员可以通过fork的返回值来区分父进程和子进程，然后再执行不同的代码。

```c
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
 
void fatchfunc()  // 父进程流程的主函数
{
  printf("我是老爸。\n");
}
 
void childfunc()  // 子进程流程的主函数
{
  printf("我是儿子。\n");
}
 
int main()
{
  if (fork()>0) { printf("这是父进程，将调用fatchfunc()。\n"); fatchfunc();}
  else { printf("这是子进程，将调用childfunc()。\n");  childfunc();}
 
  sleep(1); printf("父子进程执行完自己的函数后都来这里。\n"); sleep(1);
}
```

在上文上已提到过，子进程拷贝了父进程的堆栈段和数据段，也就是说，在父进程中定义的变量子进程中会复制一个副本，fork之后，子进程对变量的操作不会影响父进程，父进程对变量的操作也不会影响子进程。**fork之后的父子进程在内存中是独立的数据空间。**





